import AudioPlayer from './audio-player';

class AudioPlayerService {

  /**
     * Initialize player and kick off contact with feed.fm. This method creates
     * a singleton AudioPlayer that can be retrieved via the `player` property
     * or the `getAvailablePlayer` method. Multiple calls to this method after 
     * the first are ignored.
     * 
     * @returns {AudioPlayer} - the singleton AudioPlayer instance
     */

  initialize(options = {}) {
    if (this._audioPlayer) {
      // do not re-initialize
      return this._audioPlayer;
    }

    options = {
      token: 'demo',
      secret: 'demo',
      ...options
    };

    // create an audio player
    const audioPlayer = this._audioPlayer = new AudioPlayer();

    // keep track of folks waiting on availability
    this._availabilityListeners = [];

    // kick off native audio player creation
    audioPlayer.initialize(options.token, options.secret, this._onAvailability.bind(this));

    return audioPlayer;
  }

  /**
     * This callback is passed either `null` or an AudioPlayer instance to indicate
     * music is unavailable or available for playback, respectively.
     * 
     * @callback availabilityCallback
     * @param {object} playerOrNull - when `null`, no music is available for playback. When
     *   not `null`, this parameter is the AudioPlayer object
     */

  /**
     * Retrieve the AudioPlayer instance via promise or callback after it has 
     * been determined whether music is available or not. This is really a 
     * convenience function that takes the place of having to watch for the
     * player to transition to a valid state and then retrieve the list of
     * available music stations.
     * 
     * @param {availabilityCallback} [onAvailability] - optional availability callback
     * @returns {null|Promise} when no callback is passed, this method returns a promise that
     *   yields null or the AudioPlayer object that has music available or playback
     */

  getAvailablePlayer(onAvailability) {
    if (onAvailability) {
      // callback function
      if (this.available === true) {
        return onAvailability(this);

      } else if (this.available === false) {
        return onAvailability(null);

      } else {
        this._availabilityListeners.push(onAvailability);
      }

    } else {
      // return a promise that resolves to player or null
      if (this.available === true) {
        return Promise.resolve(this);

      }
      if (this.available === false) {
        return Promise.resolve(null);

      } else {
        return new Promise((resolve) => {
          this._availabilityListeners.push((playerOrNull) => {
            resolve(playerOrNull);
          });
        });
      }
    }
  }

  /**
     * Return initialized player or throw exception if `initialize()` hasn't been called yet.
     */

  get player() {
    if (!this._audioPlayer) throw new Error('initialize() not called before retrieving FeedAudoiPlayer');

    return this._audioPlayer;
  }

  /**
   * Pass on 'available' event to clients.
   * 
   * @param {boolean} available - true when music is available for playback
   */
  _onAvailability(available) {
    this.available = available;

    const playerOrNull = available ? this._audioPlayer : null;
    while (this._availabilityListeners.length > 0) {
      const listener = this._availabilityListeners.shift();

      try {
        listener(playerOrNull);
      } catch (e) {
        console.error('availability listener threw an error', e);
      }
    }
  }
}

const audioPlayerService = new AudioPlayerService();

export default audioPlayerService;