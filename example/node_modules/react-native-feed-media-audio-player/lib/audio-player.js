
import { NativeModules, NativeEventEmitter } from 'react-native';
import NanoEvents from 'nanoevents';
const { RNFMAudioPlayer } = NativeModules;

/**
 * AudioPlayer represents a connection to the native FMAudioPlayer instance. This class tries
 * to keep track of the state of the native player and forward on events to javascript
 * listeners.
 * 
 * To use this:
 * 
 * let player = new AudioPlayer(); // player will be uninitialized
 * player.initialize(token, secret, availability); // initialize native player, register for availability event
 * 
 */

class AudioPlayer {

    constructor() {
        // default state until we hear from the player
        this._state = RNFMAudioPlayer.audioPlayerPlaybackStateUninitialized;

        // how we communicate to clients:
        this._emitter = new NanoEvents();

        // register to get notices from native event emitters
        const nativeEmitter = new NativeEventEmitter(RNFMAudioPlayer);

        this.availabilitySubscription = nativeEmitter.addListener('availability', this.onAvailability.bind(this));
        this.stateChangeSubscription = nativeEmitter.addListener('state-change', this.onStateChange.bind(this));
        this.onStationChangeSubscription = nativeEmitter.addListener('station-change', this.onStationChange.bind(this));
        this.onPlayStartedSubscription = nativeEmitter.addListener('play-started', this.onPlayStarted.bind(this));
        /*
        this.onSkipFailedSubscription = emitter.addListener('skip-failed', (play) => this.onSkipFailed(play));
        */
    }

    /**
     * This callback is passed true or false to indicate music availability
     * 
     * @callback availabilityCallback
     * @param {boolean} available - true when music is available for playback. false otherwise.
     */

    /**
     * 
     * @param {string} token - token value provided by Feed.fm
     * @param {string} secret - secret value provided by Feed.fm
     * @param {availabilityCallback} [availability] - callback that is informed when availability is determined
     */
    initialize(token, secret, availability) {
        RNFMAudioPlayer.initializeWithToken(token, secret);

        if (availability) {
            this.once('availability', availability);
        }
    }

    /**
     * Event registration endpoint
     */
    on() {
        return this._emitter.on.apply(this._emitter, arguments);
    }

    /**
     * Register a callback for the given event. After a single call of the callback function,
     * the event is unsubscribed from.
     * 
     * @param {string} event 
     * @param {function} callback 
     */
    once(event, callback) {
        const unbind = this._emitter.on(event, function () {
            unbind();
            callback.apply(this, arguments);
        });
        return unbind;
    }

    play() {
        RNFMAudioPlayer.play();
    }

    pause() {
        RNFMAudioPlayer.pause();
    }

    skip() {
        RNFMAudioPlayer.skip();
    }

    stop() {
        RNFMAudioPlayer.stop();
    }

    get playbackState() {
        switch (this._state) {
            case RNFMAudioPlayer.audioPlayerPlaybackStateUninitialized: return 'UNINITIALIZED';
            case RNFMAudioPlayer.audioPlayerPlaybackStateUnavailable: return 'UNAVAILABLE';
            case RNFMAudioPlayer.audioPlayerPlaybackStateWaitingForItem: return 'WAITING_FOR_ITEM';
            case RNFMAudioPlayer.audioPlayerPlaybackStateReadyToPlay: return 'READY_TO_PLAY';
            case RNFMAudioPlayer.audioPlayerPlaybackStatePlaying: return 'PLAYING';
            case RNFMAudioPlayer.audioPlayerPlaybackStatePaused: return 'PAUSED';
            case RNFMAudioPlayer.audioPlayerPlaybackStateStalled: return 'STALLED';

            default: return 'UNINITIALIZED';
        }
    }

    get currentPlay() {
        return this._currentPlay;
    }

    set activeStation(station) {
        RNFMAudioPlayer.setActiveStation(station.id);
    }

    get activeStation() {
        return this._activeStation;
    }

    get elapsedTime() {
        const previouslyElapsed = this._elapsedTimeMilliseconds || 0;
        const sinceLastStateChange = (this._startTimeMilliseconds === 0) ? 0 : (this._startTimeMillis - Date.now());
        const total = previouslyElapsed + sinceLastStateChange;

        return total;
    }

    get duration() {
        return 0;
    }

    set secondsOfCrossfade(seconds) {

    }

    set crossfadeInEnabled(enabled) {

    }

    get stations() {
        return this._stations;
    }

    /**
     * Receives 'availability' event from native player. This event includes the
     * list of stations the player has received and the currently active station.
     * 
     * The event passed in has the structure:
     * 
     * {
     *   available: true|false,
     *   stations: [ { ... }, ... ]
     *   activeStationId: XX
     * }
     * 
     * This method emits an 'availability' event to listeners
     */

    onAvailability(props) {
        let available = this.available = props.available;

        if (available) {
            this._stations = props.stations;
            this._activeStation = props.stations.find((station) => station.id === props.activeStationId);
        }

        this._emitter.emit('availability', available, this);
    }

    /**
     * Receives event from native code indicating that the state of the player has
     * changed.
     * 
     * The object passed in looks like:
     * {
     *   state: XX
     *   stations: [ ... ]
     *   activeStationId: XX
     * }
     */

    onStateChange(props) {
        if (props.state == RNFMAudioPlayer.audioPlayerPlaybackStateRequestingSkip) {
            // don't change the state - ignore this
            return;
        }

        if (this._state == props.state) {
            // we might be transitioning out of skip state 
            return;
        }

        this._state = props.state;

        console.log('state changed', props);

        if (props.stations) {
            this._stations = props.stations;
            this._activeStation = props.stations.find((station) => station.id === props.activeStationId);
        }

        /*
        //state, play, startTimeMilliseconds, elapsedTimeMilliseconds) {

        this._currentPlay = play;
        this._startTimeMilliseconds = startTimeMilliseconds;
        this._elapsedTimeMilliseconds = elapsedTimeMilliseconds;
        */

        this._emitter.emit('state-change', this.playbackState, this);
    }

    /**
     * Receives event from native code indicating that the active station has changed.
     * 
     * The object passed in looks like:
     * {
     *   activeStationId: XX
     * }
     * 
     * @param {object} props 
     */
    onStationChange(props) {
        this._activeStation = this._stations.find((station) => station.id === props.activeStationId);

        this._emitter.emit('station-change', this._activeStation, this);
    }

    /**
     * Receives event from native code indicating the given song has started playback.
     * 
     * The object passed in looks like:
     * {
     *   play: {
     *     title: 'xx',
     *     artist: 'xx',
     *     track: 'xx',
     *     metadata: { ... }
     *   }
     * }
     * @param {object} props 
     */
    onPlayStarted(props) {
        const play = props.play;

        this._currentPlay = play;

        console.warn('play-started', this._currentPlay);
        
        this._emitter.emit('play-started', this._currentPlay, this);
    }
/*
    onPlayStarted(play, startTimeMilliseconds, elapsedTimeMilliseconds) {
        this._currentPlay = play;
        this._startTimeMilliseconds = startTimeMilliseconds;
        this._elapsedTimeMilliseconds = elapsedTimeMilliseconds;

        this.emitter.emit('play-started', play);
    }

    onSkipFailed(play) {
        this.emitter.emit('skip-failed', play);
    }

    destructor() {
        // when should we do this?
        this.availableUnavailableSubscription.remove();
        this.stateChangeSubscription.remove();
        this.onStationChangeSubscription.remove();
        this.onPlayStartedSubscription.remove();
        this.onSkipFailedSubscription.remove();
    }
    */
}

export default AudioPlayer;