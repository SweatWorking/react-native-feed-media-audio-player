
import { NativeModules, NativeEventEmitter } from 'react-native';
import NanoEvents from 'nanoevents';
const { RNFMAudioPlayer } = NativeModules;
import States from './audio-player-states';

/**
 * AudioPlayer represents a connection to the native FMAudioPlayer instance. This class tries
 * to keep track of the state of the native player and forward on events to javascript
 * listeners.
 * 
 * To use this:
 * 
 * let player = new AudioPlayer(); // player will be uninitialized
 * player.initialize(token, secret, availability); // initialize native player, register for availability event
 * 
 */

class AudioPlayer {

    constructor() {
        // default state until we hear from the player
        this._state = States.UNINITIALIZED;

        // how we communicate to clients:
        this._emitter = new NanoEvents();

        // register to get notices from native event emitters
        const nativeEmitter = new NativeEventEmitter(RNFMAudioPlayer);

        this.availabilitySubscription = nativeEmitter.addListener('availability', this.onAvailability.bind(this));
        this.stateChangeSubscription = nativeEmitter.addListener('state-change', this.onStateChange.bind(this));
        this.onStationChangeSubscription = nativeEmitter.addListener('station-change', this.onStationChange.bind(this));
        /*
        this.onPlayStartedSubscription = emitter.addListener('play-started', (play) => this.onPlayStarted(play));
        this.onSkipFailedSubscription = emitter.addListener('skip-failed', (play) => this.onSkipFailed(play));
        */
    }

    /**
     * This callback is passed true or false to indicate music availability
     * 
     * @callback availabilityCallback
     * @param {boolean} available - true when music is available for playback. false otherwise.
     */

    /**
     * 
     * @param {string} token - token value provided by Feed.fm
     * @param {string} secret - secret value provided by Feed.fm
     * @param {availabilityCallback} availability - callback that is informed when availability is determined
     */
    initialize(token, secret, availability) {
        RNFMAudioPlayer.initializeWithToken(token, secret);

        if (availability) {
            this.once('availability', availability);
        }
    }

    /**
     * Event registration endpoint
     */
    on() {
        return this._emitter.on.apply(this, arguments);
    }

    /**
     * Register a callback for the given event. After a single call of the callback function,
     * the event is unsubscribed from.
     * 
     * @param {string} event 
     * @param {function} callback 
     */
    once(event, callback) {
        const unbind = this._emitter.on(event, function () {
            unbind();
            callback.apply(this, arguments);
        });
        return unbind;
    }

    play() {
        RNFMAudioPlayer.play();
    }

    pause() {
        RNFMAudioPlayer.pause();
    }

    skip() {
        RNFMAudioPlayer.skip();
    }

    stop() {
        RNFMAudioPlayer.stop();
    }

    get currentPlay() {
        return this._currentPlay;
    }

    set activeStation(station) {
        RNFMAudioPlayer.setActiveStation(station.id);
    }

    get activeStation() {
        return this._activeStation;
    }

    get elapsedTime() {
        const previouslyElapsed = this._elapsedTimeMilliseconds || 0;
        const sinceLastStateChange = (this._startTimeMilliseconds === 0) ? 0 : (this._startTimeMillis - Date.now());
        const total = previouslyElapsed + sinceLastStateChange;

        return total;
    }

    get duration() {
        return 0;
    }

    set secondsOfCrossfade(seconds) {

    }

    set crossfadeInEnabled(enabled) {

    }

    get stations() {
        return [];
    }

    /**
     * Receives 'availability' event from native player. This event includes the
     * list of stations the player has received and the currently active station.
     * 
     * The event passed in has the structure:
     * 
     * {
     *   available: true|false,
     *   stations: [ { ... }, ... ]
     *   activeStationId: XX
     * }
     * 
     * This method emits an 'availability' event to listeners
     */

    onAvailability(props) {
        let available = this.available = props.available;

        if (available) {
            this._stations = props.stations;
            this._activeStation = props.stations.find((station) => station.id === props.activeStationId);
        }

        this._emitter.emit('availability', available);
    }

    /**
     * Receives event from native code indicating that the state of the player has
     * changed.
     * 
     * The object passed in looks like:
     * {
     *   state: XX
     * }
     */

    onStateChange(props) {
        this._state = props.state;
        console.warn('state changed to ', this._state);
        /*
        //state, play, startTimeMilliseconds, elapsedTimeMilliseconds) {

        this._currentPlay = play;
        this._startTimeMilliseconds = startTimeMilliseconds;
        this._elapsedTimeMilliseconds = elapsedTimeMilliseconds;

        this.emitter.emit('state-change', state);
        */
    }

    /**
     * Receives event from native code indicating that the active station has changed.
     * 
     * The object passed in looks like:
     * {
     *   activeStationId: XX
     * }
     * 
     * @param {object} props 
     */
    onStationChange(props) {
        this._activeStation = this._stations.find((station) => station.id === props.activeStationId);

        console.warn('station changed to', this._activeStation, props);

        this.emitter.emit('station-change', this._activeStation);
    }

/*
    onPlayStarted(play, startTimeMilliseconds, elapsedTimeMilliseconds) {
        this._currentPlay = play;
        this._startTimeMilliseconds = startTimeMilliseconds;
        this._elapsedTimeMilliseconds = elapsedTimeMilliseconds;

        this.emitter.emit('play-started', play);
    }

    onSkipFailed(play) {
        this.emitter.emit('skip-failed', play);
    }

    destructor() {
        // when should we do this?
        this.availableUnavailableSubscription.remove();
        this.stateChangeSubscription.remove();
        this.onStationChangeSubscription.remove();
        this.onPlayStartedSubscription.remove();
        this.onSkipFailedSubscription.remove();
    }
    */
}

export default AudioPlayer;